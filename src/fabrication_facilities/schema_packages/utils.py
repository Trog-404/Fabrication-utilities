import re
from collections import defaultdict
from typing import (
    TYPE_CHECKING,
)

import numpy as np
from nomad.datamodel.data import ArchiveSection, EntryData
from nomad.datamodel.metainfo.basesections import ElementalComposition
from nomad.datamodel.metainfo.eln import Chemical
from nomad.metainfo import (
    Package,
    Quantity,
    Section,
    SubSection,
)

if TYPE_CHECKING:
    from nomad.datamodel.datamodel import (
        EntryArchive,
    )
    from structlog.stdlib import (
        BoundLogger,
    )

m_package = Package(name='Etching workflow schema')


def parse_chemical_formula(formula):
    formula = formula.replace('Â·', '.')
    if '.' in formula:
        main_part, hydrate_part = formula.split('.')
    else:
        main_part, hydrate_part = formula, None

    def extract_elements(compound):
        # Espressione per trovare elementi chimici seguiti da un numero opzionale
        matches = re.findall(r'([A-Z][a-z]*)(\d*)', compound)
        elements = defaultdict(int)

        for element, count in matches:
            elements[element] += int(count) if count else 1

        return elements

    element_main = defaultdict(int)

    # Espandiamo le parentesi prima di estrarre gli elementi
    while '(' in main_part:
        main_part = re.sub(
            r'\(([^()]*)\)(\d+)', lambda m: m.group(1) * int(m.group(2)), main_part
        )

    # Trova elementi e numeri
    matches = re.findall(r'([A-Z][a-z]*)(\d*)', main_part)

    for element, count in matches:
        element_main[element] += (
            int(count) if count else 1
        )  # Se il numero manca, assume 1

    if hydrate_part:
        hydrate_match = re.match(r'(\d*)H2O', hydrate_part)
        if hydrate_match:
            water_molecules = (
                int(hydrate_match.group(1)) if hydrate_match.group(1) else 1
            )
            elements_hydrate = extract_elements('H2O')

            for element, count in elements_hydrate.items():
                element_main[element] += count * water_molecules

    # Convertiamo il dizionario in due liste ordinate
    elements = list(element_main.keys())
    counts = list(element_main.values())

    return elements, counts


class Massflow_controller(Chemical, EntryData, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        a_eln={'overview': True, 'hide': ['lab_id', 'datetime']},
    )
    massflow = Quantity(
        type=np.float64,
        a_eln={
            'component': 'NumberEditQuantity',
            'defaultDisplayUnit': 'centimeter^3/minute',
        },
        unit='centimeter^3/minute',
    )

    elemental_composition = SubSection(section_def=ElementalComposition, repeats=True)

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        super().normalize(archive, logger)
        if self.chemical_formula:
            elements, counts = parse_chemical_formula(self.chemical_formula)
            total = 0
            for token in counts:
                total += int(token)
            if total != 0:
                elemental_fraction = np.array(counts) / total
                elementality = []
                for entry in elements:
                    i = 0
                    elemental_try = ElementalComposition()
                    elemental_try.element.append(entry)
                    elemental_try.atomic_fraction.append(elemental_fraction[i])
                    i += 1
                    elementality.append(elemental_try)
            else:
                print('No elements provided')
            self.elemental_composition.elementality


m_package.__init_metainfo__()
