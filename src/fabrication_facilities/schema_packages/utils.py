import re
from collections import defaultdict
from typing import (
    TYPE_CHECKING,
)

import numpy as np
from nomad.datamodel.data import ArchiveSection, EntryData
from nomad.datamodel.metainfo.basesections import ElementalComposition
from nomad.datamodel.metainfo.eln import Chemical
from nomad.metainfo import (
    Datetime,
    Package,
    Quantity,
    Section,
    SubSection,
)
from fabrication_facilities.schema_packages.fabrication_steps import (
    FabricationProcessStep,
)

if TYPE_CHECKING:
    from nomad.datamodel.datamodel import (
        EntryArchive,
    )
    from structlog.stdlib import (
        BoundLogger,
    )

m_package = Package(name='Etching workflow schema')


def parse_chemical_formula(formula):
    formula = formula.replace('Â·', '.')
    if '.' in formula:
        main_part, hydrate_part = formula.split('.')
    else:
        main_part, hydrate_part = formula, None

    def extract_elements(compound):
        # Espressione per trovare elementi chimici seguiti da un numero opzionale
        matches = re.findall(r'([A-Z][a-z]*)(\d*)', compound)
        elements = defaultdict(int)

        for element, count in matches:
            elements[element] += int(count) if count else 1

        return elements

    element_main = defaultdict(int)

    # Espandiamo le parentesi prima di estrarre gli elementi
    while '(' in main_part:
        main_part = re.sub(
            r'\(([^()]*)\)(\d+)', lambda m: m.group(1) * int(m.group(2)), main_part
        )

    # Trova elementi e numeri
    matches = re.findall(r'([A-Z][a-z]*)(\d*)', main_part)

    for element, count in matches:
        element_main[element] += (
            int(count) if count else 1
        )  # Se il numero manca, assume 1

    if hydrate_part:
        hydrate_match = re.match(r'(\d*)H2O', hydrate_part)
        if hydrate_match:
            water_molecules = (
                int(hydrate_match.group(1)) if hydrate_match.group(1) else 1
            )
            elements_hydrate = extract_elements('H2O')

            for element, count in elements_hydrate.items():
                element_main[element] += count * water_molecules

    # Convertiamo il dizionario in due liste ordinate
    elements = list(element_main.keys())
    counts = list(element_main.values())

    return elements, counts


class Massflow_controller(Chemical, EntryData, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        a_eln={'overview': True, 'hide': ['lab_id', 'datetime']},
    )
    massflow = Quantity(
        type=np.float64,
        a_eln={
            'component': 'NumberEditQuantity',
            'defaultDisplayUnit': 'centimeter^3/minute',
        },
        unit='centimeter^3/minute',
    )

    elemental_composition = SubSection(section_def=ElementalComposition, repeats=True)

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        super().normalize(archive, logger)
        if self.chemical_formula:
            elements, counts = parse_chemical_formula(self.chemical_formula)
            total = 0
            for token in counts:
                total += int(token)
            if total != 0:
                elemental_fraction = np.array(counts) / total
                elementality = []
                i = 0
                for entry in elements:
                    elemental_try = ElementalComposition()
                    elemental_try.element = entry
                    elemental_try.atomic_fraction = elemental_fraction[i]
                    i += 1
                    elementality.append(elemental_try)
            else:
                print('No elements provided')
            self.elemental_composition = elementality


class Jobdone(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        a_eln={
            'properties': {
                'order': [
                    'name',
                    'job_number',
                    'notes',
                    'starting_date',
                    'ending_date',
                    'id_item_processed',
                    'referenced_activity',
                ]
            }
        },
    )
    name = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    job_number = Quantity(
        type=int,
        a_eln={'component': 'NumberEditQuantity'},
    )
    notes = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    starting_date = Quantity(
        type=Datetime,
        a_eln={'component': 'DateTimeEditQuantity'},
    )
    ending_date = Quantity(
        type=Datetime,
        a_eln={'component': 'DateTimeEditQuantity'},
    )
    id_items_processed = Quantity(
        type=int,
        a_eln={'component': 'NumberEditQuantity'},
        shape=['*'],
    )
    referenced_activities = Quantity(
        type=FabricationProcessStep,
        shape=['*'],
        a_eln={'component': 'ReferenceEditQuantity'},
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `Jobdone` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


m_package.__init_metainfo__()
